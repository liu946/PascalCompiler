# PascalCompiler

最简单的 pascal 编译器，基本什么功能都没有实现。

## 使用方法

直接从program开始写一段代码，使用var定义变量，不要定义函数，不要定义过程，不要使用多维数组。

只能使用while循环，if，if-else结构。

只能调用scanf，printf函数，调用与C语言相同。

经过一系列乱七八糟的操作，最后打印出来一篇可以直接拿到VS运行的MASM代码（虽然这之前还需要配置一顿VS）。

---

## 总结一下这个项目

1. 词法分析，这个分析器实现的比较简单，id和keyword一起识别的，如果不改动逻辑的话只能完成大部分语言的词法分析，不支持正则表达式。因为这里的DFA是半手动构造的，没有完全等价实现lex，如果修改的话需要改动一下DFA的constructor。

2. 词法分析没有操作符号表，这里生成token序列，直接传入语法分析器的，如果需要使用此词法分析器，记得在语义分析的时候注册变量。（这样做虽然不是编译书推荐的方法，但是可以避免词法分析的复杂性，也可以在语法分析的时候统一检查重复定义，未定义等等情况）

3. 语法分析器是完全按照LR(1)识别方法设计的，这里的设计应该是考虑到了所有的边界情况，包括FIRST集合的构造和状态机的实现。这里实现的功能与YACC等价，除了自动机构造的时候，没有考虑LALR状态缩减。但是这是实现的问题，在使用上和对于文法的描述能力上与YACC的LALR(1)实现没有任何区别。

4. 语法分析LR(1)实现的好处很多。

	a. 对文法的限制极少
	b. 可以左递归，自顶向下的方法基本都不行
	c. 支持二义性文法，只要在一个后继字符的情况下就可以区分，不会产生冲突。如果想改成LR(2)或更多展望符号的也比较容易。

5. 语法分析器的实现比较有参考价值，如果希望能够从这个系统中看到一点什么东西，可能也就这一块能入眼了。其实这个编译器中其他地方也没有实现什么了，也就是这里实现的比较完整了。233

6. 语义分析器以后的部分就没有完整实现了。这里每个部分都选取了一部分最简的功能以保证最后的实现，如果有兴趣能给补充一点代码最好。多谢。以下是一些todo的注释，可能留给有兴趣再写的人，留给将来有闲工夫的我，或者。。。

7. 完成变量的类型系统，从语义分析之后就没考虑变量类型了，全都使用的4byte类型。这里涉及到类型转换代码的翻译和对于不同类型采用不同指令翻译的这种关系模型的建立。也涉及到寄存器分配时候的类型控制，比如要使系统知道EAX和AX和AL是占用一寄存器的，这些寄存器在分配之后是会互相影响的。知道每个寄存器的位数是多少并合理分配。

8. 完成函数调用，这里注意PASCAL函数是可以嵌套定义的，这里需要使用动态链和静态联结合，这里访问链的构造是一个难点，系统没有实现内存的栈式分配。如果需要完成函数调用，这里也要进行修改。

## 说一下编译这个课程

编译这课程内容太多了，然而哈工大只分配了这么一点时间，无论实验还是课程都很难深入学习，但是这也是很多课程的通病，也没有什么好办法，毕竟一天32小时的学习时间你们这些学生都保证不了是不是。内容多自然就导致了讲的不细致，这个项目最后一半实现的这么仓促，一个是时间不够，一个更关键的问题就是这个课程根本没有讲清楚之后的内容怎么实现，在查资料的过程之中，发现寄存器的分配其实是大有文章的，其中还有相应的染色器算法等等内容，课程上完全就没有介绍。课程的指导老师感觉自己就没有真正实现过编译器，问什么问题从理论上回答一下，完全不考虑编程会遇到什么问题。老师对于编程语言的理解也很有限。很多理论上的东西应该如果映射到程序实现概念也不是很清楚。说实话这个课程还是有一定难度的，希望同学老师能够都自己实现一下这个系统，你的程序真的能跑出来这4000种状态而不出问题，体验一下从几百种状态的生成中查找bug的状态，才能知道在实现的时候什么是值得注意的，什么是容易出问题的，而不是问具体一些就是一句“这就是你编程的具体实现了”能够搪塞的了的。

